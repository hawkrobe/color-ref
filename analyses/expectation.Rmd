---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tidyverse)
library(knitr)
library(scales)
library(xtable)
library(broom)
```
# load data
```{r}
dExpectation = read_csv('./expectation/expectations-by-condition.csv') 
dTruth = read_csv('./expectation/ground-truth-by-condition.csv') 
```

# Word level response
```{r}
# Z score averages of expectation rating and actual percent matches (across participants) and compare
expectation <- aggregate(dExpectation[, 2], list(dExpectation$word), mean) %>% 
  mutate(zscore = (sliderResponse - mean(sliderResponse))/sd(sliderResponse)) %>%
  rename(word = "Group.1", avgExpectation = sliderResponse)

truth <-  aggregate(dTruth[, 2], list(dTruth$word), mean) %>% 
  mutate(zscore = (groundTruth - mean(groundTruth))/sd(groundTruth))

# plot word level responses (averaged over participants + z-scored)
scatter.smooth(x=expectation$zscore, y=truth$zscore, xlab="Average expecation rating", ylab="Average percent agreement", main="Expected agreement vs. actual agreement")
```
# Compare DeltaE among participants' block 2 responses against average slider rating
```{r}
dDeltaE = read_csv('./deltaE/sorted-deltaE-CIE2000-block2.csv') 

# zscoring:
deltaE <- dDeltaE[order(dDeltaE$word),] %>%
  mutate(zscore = (deltaE - mean(deltaE))/sd(deltaE))
# averaging slider + zscoring
expectation <- aggregate(dExpectation[, 2], list(dExpectation$word), mean) %>%
  rename(word = "Group.1", avgExpectation = sliderResponse) %>%
  mutate(zscore = (avgExpectation - mean(avgExpectation))/sd(avgExpectation))

# plot
scatter.smooth(x=expectation$zscore, y=deltaE$zscore, xlab="Average expecation rating", ylab="Average Delta E among block2 repsonses", main="Expected agreement vs. average Delta E")

# correlation
cor.test(expectation$zscore, deltaE$zscore)
```
# Expectation ratings vs. ground truth (calculated as percentage of total response that agreed with each participant's response)

### The following analyses show that the ground truth agreements are much lower than the slider responses for expected agreement. Plotting the distributions of the expected and actual agreements for the 10 words with the least entropy in their prior distributions (i.e. most agreement), shows that only the words whose distributions would be expected to center around yellows, have an actual agreement that is somewhat reflective of their concreteness and expectation ratings. Meanwhile, the words whose response distributions would be expected to center on reds ("tomato", "fire", "apple") and greens ("spinach", "vegetable", "tree") have actual agreements that are much lower than expected. In the context of the munsell space that participants selected from--one which has a larger variety of red and green color choices, but very few yellow ones--this discrepancy suggests that when people rate their expected agreement they're considering the space of all reds, greens, etc. as "sharing" their color association (vs. the particular color they picked), but in reality words like "tomato" and "fire" and "vegetable" have many of different red or green responses that deflate the agreement.
```{r}
library("ggpubr")
ggboxplot(dExpectation, y = "sliderResponse", main= "Expected Agreement by Condition",
          color = "condition", order = c("concrete", "abstract"), ylim = c(0, 100),
          ylab = "% of population expected to share association") +
  theme(axis.ticks.x=element_blank(), axis.text.x=element_blank(), axis.title.x=element_blank())
```

### Ground truth boxplot
```{r}
ggboxplot(dTruth, y = "groundTruth", main= "Actual Agreement by Condition",
          color = "condition", order = c("concrete", "abstract"), ylim = c(0, 100),
          ylab = "% of population actually sharing color association") +
    theme(axis.ticks.x=element_blank(), axis.text.x=element_blank(), axis.title.x=element_blank())
```

### plotting expected and actual agreement for top 10 words individually
```{r}
# define "expected" and "actual" condition columns
expect <- rep(c("expected"),each=981)
actual <- rep(c("actual"),each=981)

# prepare datasets to be combined
selectedExpectation <- filter(dExpectation, word %in% c("lemon", "sun", "tomato", "fire", "apple", "spinach", "vegetable", "tree", "daffodil")) %>%
  subset(select=-condition) %>%
  rename(value = sliderResponse) %>%
  cbind(condition = expect)
  
selectedActual <- filter(dTruth, word %in% c("lemon", "sun", "tomato", "fire", "apple", "spinach", "vegetable", "tree", "daffodil")) %>%
  subset(select=-condition) %>%
  rename(value = groundTruth) %>%
  cbind(condition = actual)
# append datasets
both <- rbind(selectedActual, selectedExpectation)

# plot
ggplot(both, aes(x=word, y=value, fill=condition)) +
  geom_boxplot() +
  ggtitle("Actual vs. Expected Agreement") +
  labs(y="% agreement", x = "Word") +
  # facet_wrap(~condition) +
  coord_cartesian(ylim = c(0, 100)) +
  theme(axis.text.x = element_text(size = 10, angle = 45), axis.title=element_text(size=12))

```
# Logistic regression

```{r}
require(lme4)
dLogistic = read_csv('./expectation/logistic-regression.csv') 

m <- glmer(matchYN ~ aID1Expectation + (1 | aID1), data = dLogistic)
# print the mod results without correlations among fixed effects
print(m)

```


<!-- # compare expectation to entropy for each word -->
<!-- ```{r} -->

<!-- filtered <- d %>% -->
<!--   mutate(sliderResponse = as.numeric(sliderResponse)) -->
<!-- # calculate mean per group  -->
<!-- avgExpectation <- aggregate(filtered$sliderResponse, by = list(filtered$word), FUN = mean) -->

<!-- # load and format entropy data -->
<!-- f = read_csv('./entropy/sorted-entropies-all-both.csv')  -->

<!-- f = f %>% -->
<!--   mutate(both = as.numeric(both)) -

<!-- scatter.smooth(x=f$both, y=avgExpectation$x, xlab = "Entropy of participants' color associations for all words", ylab = "Average % of population expected to share one's color association") -->
<!-- ``` -->

<!-- # attempt to combine entropy ratings and slider responses to do a mixed effect model with subject as the random effect -->
<!-- ```{r} -->
<!-- library(lme4) -->

<!-- # NEED TO JOIN DATAFRAMES -->
<!-- mixedModel <- lmer(filtered$entropy ~ d$sliderResponse  + (1|d$aID)) -->
<!-- summary(mixedModel) -->
<!-- ``` -->


