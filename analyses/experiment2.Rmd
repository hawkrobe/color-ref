---
title: "Experiment 2"
output: html_notebook
---

```{r}
library(tidyverse)
library(ggthemes)
library(lme4)
library(lmerTest)
library(tidyboot)
library(here)
library(spacesXYZ)

d.raw <- read_csv(here('data/ref-game/dataFromMongo.csv'),
              col_types = 'ccnccccccnccnncnnnncncccncccl')
```

## Implement exclusion criterion

Remove games that disconnected partway through

```{r}
completeIDs <- d.raw %>%
  filter(!is.na(correct)) %>%
  group_by(gameId) %>%
  tally() %>%
  filter(n == 48) %>%
  pull(gameId)


cat('we have', length(completeIDs), 'complete games out of the',
    d.raw %>%   group_by(gameId) %>%  tally() %>% pull(gameId) %>% length(),
    'that we recruited')
```

Remove participants who failed catch trials in pre-test or post-test.

Valid responses are a liberal boundary of all chips that could plausibly be considered red or blue.

```{r}
valid_responses_red = c(0, 9, 11, 12, 20, 22, 23, 30, 31, 33, 34, 42, 44, 45, 
                        52, 53, 55, 56, 64, 66, 67, 74, 75, 77, 78, 85, 86)
valid_responses_blue = c(4, 5, 6, 15, 16, 17, 18, 26, 27, 28, 29, 37, 38, 39, 
                         40, 48, 49, 50, 51, 59, 60, 61, 62, 70, 71, 72, 73, 81, 82, 83, 84)
passedCatchIDs <- d.raw %>%
  filter(gameId %in% completeIDs) %>%
  filter(condition == 'catch') %>%
  mutate(valid = ifelse(target == 'blue', button_pressed %in% valid_responses_blue, 
                        button_pressed %in% valid_responses_red)) %>%
  group_by(gameId) %>%
  summarize(valid = all(valid)) %>%
  filter(valid) %>%
  pull(gameId) %>%
  unique()

cat(length(passedCatchIDs), '/', length(completeIDs), 'complete games had both participants pass the catch trials')
```

Look at overall RT distribution (some on the low end...)

```{r}
d.raw %>%
  filter(gameId %in% passedCatchIDs) %>%
  filter(phase == 'refGame') %>%
  ggplot(aes(x = log(rt))) +
    geom_histogram() +
    facet_grid(dataType ~. )
```
Look at participant-level rt distribution for any outliers that consistently responded much quicker/slower than others.

```{r}
d.raw %>%
  filter(gameId %in% passedCatchIDs) %>%
  filter(phase == 'refGame') %>%
  group_by(playerId, dataType) %>%
  summarize(rt = mean(log(rt))) %>%
  ggplot(aes(x = rt)) +
    geom_histogram() +
    facet_grid(dataType ~. )
```

# Analysis 1: predict communciative success as a function of the prior

## Analysis 1.1: using independently elicited norms 

We start using entropy of population distribution of associations measured from earlier participants as a predictor of communicative success

```{r}
entropies <- read_csv(here('analyses/entropy/sorted-entropies-all-both.csv')) %>%
  mutate(quantile = cut_number(both, n = 5)) %>%
  rename(target = word, prior_entropy = both) %>%
  select(-condition)

clicks <- d %>%
  filter(dataType == 'clickedWord') %>%
  filter(gameId %in% passedCatchIDs) %>%
  select(which(colMeans(is.na(.)) < 0.5)) %>%
  separate(context_id, into = c('condition', 'context_id')) %>%
  left_join(entropies, by = c('target')) 
```

Plot by condition 

```{r}
clicks %>%
  group_by(blockNum, condition) %>%
  tidyboot::tidyboot_mean(correct) %>%
  ggplot(aes(x = blockNum, y = empirical_stat, color = condition)) +
    geom_point() +
    geom_hline(yintercept = 0.25, linetype = 'dotted') +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    geom_smooth(method = 'lm', se = F, formula = y ~ poly(x,1)) +
    theme_few() +
    ylim(0.25, 1.1) +
    labs(y = '% accuracy', x = 'block #')
```

Plot by decile 

```{r}
clicks %>%
  group_by(blockNum, decile) %>%
  tidyboot::tidyboot_mean(correct) %>%
  ggplot(aes(x = blockNum, y = empirical_stat, color = as.numeric(decile), group = as.numeric(decile))) +
    geom_point() +
    geom_hline(yintercept = c(0.25, 1), linetype = 'dotted') +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    geom_smooth(method = 'lm', se = F, formula = y ~ poly(x,1)) +
    theme_few() +
    ylim(0.25, 1.1) +
    labs(y = '% accuracy', x = 'block #')
```

Look at the relationship between avg prior entropy and accuracy on each block.

```{r}
clicks %>%
  group_by(blockNum, context_id) %>%
  summarize(correct = mean(correct),
            entropy = mean(prior_entropy)) %>%
  ggplot(aes(x = entropy, y = correct)) +
    geom_point() +
    geom_smooth(method = 'lm', se = F, formula = y ~ poly(x,1)) +
    theme_few() +
    facet_wrap(~ blockNum) +
    labs(y = '% accuracy', x = 'block #')
```

```{r}
clicks %>%  
  glmer(correct ~ condition * blockNum + 
                  (1 + condition + blockNum  | gameId) + 
                  (1 + condition + blockNum  | context_id),
      family = 'binomial',
      data = .) %>%
  summary()
```

## Analysis 1.2: Using pre-test similarity

Extract response similarity on pre-test

```{r}
# convert to LAB
colors <- d %>%
  filter(dataType == 'sentColor') %>%
  filter(gameId %in% passedCatchIDs) %>%
  select(which(colMeans(is.na(.)) < 0.5)) %>%
  do(cbind(., data.frame(convertColor(matrix(c(.$response_r, .$response_g, .$response_b), ncol = 3)/255, 
                          from = 'sRGB', to = 'Lab'))))

# get distance between pre-test responses for partners
pre_test_dists <- colors %>%
  filter(phase == 'pre') %>%
  select(gameId, playerId, target, L, a, b) %>%
  group_by(gameId, target) %>%
  do(data.frame(prior_dist = as.matrix(dist(.))[upper.tri(dist(.))]))
```

```{r}
clicks %>%
  left_join(pre_test_dists) %>%
  mutate(dist_quantile = cut_number(prior_dist, n = 5)) %>%
  group_by(blockNum, dist_quantile) %>%
  tidyboot::tidyboot_mean(correct) %>%
  ggplot(aes(x = blockNum, y = empirical_stat, 
             color = as.numeric(dist_quantile), group = as.numeric(dist_quantile))) +
    geom_point() +
    geom_hline(yintercept = c(0.25, 1), linetype = 'dotted') +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    geom_smooth(method = 'lm', se = F, formula = y ~ poly(x,1)) +
    theme_few() +
    ylim(0.25, 1.1) +
    labs(y = '% accuracy', x = 'block #')
```

```{r}
clicks %>%
  left_join(pre_test_dists) %>%
  group_by(blockNum, context_id) %>%
  summarize(correct = mean(correct),
            dist = mean(prior_dist)) %>%
  ggplot(aes(x = dist, y = correct)) +
    geom_point() +
    geom_smooth(method = 'lm', se = F, formula = y ~ poly(x,1)) +
    theme_few() +
    facet_wrap(~ blockNum) +
    labs(y = '% accuracy', x = 'block #')
```

```{r}
clicks %>%  
  left_join(pre_test_dists) %>%
  group_by(gameId) %>%
  mutate(prior_dist = scale(prior_dist, scale=T)) %>%
  glm(correct ~ prior_dist * blockNum, 
#                  (1 + prior_dist * blockNum | gameId),
      family = 'binomial',
      data = .) %>%
  summary()
```


# Analysis 2: Change from pre- to post-test

```{r}
pre_post_dists <- colors %>%
  filter(phase != 'refGame') %>%
  select(gameId, playerId, set, condition, phase, target, L, a, b) %>%
  group_by(gameId, target, phase, set, condition) %>%
  do(data.frame(prior_dist = as.matrix(dist(.))[upper.tri(dist(.))]))

pre_post_dists %>%
  filter(condition != 'catch') %>%
  group_by(set, condition, phase) %>%
  tidyboot_mean(prior_dist) %>%
  ungroup() %>%
  mutate(`set` = fct_relevel(`set`, 'test')) %>%
  mutate(phase = fct_relevel(phase, 'pre')) %>%
  ggplot(aes(x = phase, y = empirical_stat, 
             color = condition, linetype = set, 
             group = interaction(set, condition))) +
    geom_line() +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    labs(y = 'euclidean distance between partner associations', x = '') +
    ylim(0, 130) +
    theme_few()
```